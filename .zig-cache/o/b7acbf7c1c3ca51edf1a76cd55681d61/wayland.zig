//! Generated by zig-wayland

const std = @import("std");
const assert = std.debug.assert;
const posix = std.posix;

pub const client = struct {
    pub const wl = struct {
        pub const Object = common.Object;
        pub const Message = common.Message;
        pub const Interface = common.Interface;
        pub const list = common.list;
        pub const Array = common.Array;
        pub const Fixed = common.Fixed;
        pub const Argument = common.Argument;

        pub const Proxy = opaque {
            extern fn wl_proxy_create(factory: *Proxy, interface: *const Interface) ?*Proxy;
            pub fn create(factory: *Proxy, interface: *const Interface) error{OutOfMemory}!*Proxy {
                return wl_proxy_create(factory, interface) orelse error.OutOfMemory;
            }

            extern fn wl_proxy_destroy(proxy: *Proxy) void;
            pub const destroy = wl_proxy_destroy;

            extern fn wl_proxy_marshal_array(proxy: *Proxy, opcode: u32, args: ?[*]Argument) void;
            pub const marshal = wl_proxy_marshal_array;

            extern fn wl_proxy_marshal_array_constructor(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
            ) ?*Proxy;
            pub fn marshalConstructor(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
            ) error{OutOfMemory}!*Proxy {
                return wl_proxy_marshal_array_constructor(proxy, opcode, args, interface) orelse
                    error.OutOfMemory;
            }

            extern fn wl_proxy_marshal_array_constructor_versioned(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
                version: u32,
            ) ?*Proxy;
            pub fn marshalConstructorVersioned(
                proxy: *Proxy,
                opcode: u32,
                args: [*]Argument,
                interface: *const Interface,
                version: u32,
            ) error{OutOfMemory}!*Proxy {
                return wl_proxy_marshal_array_constructor_versioned(proxy, opcode, args, interface, version) orelse
                    error.OutOfMemory;
            }

            const DispatcherFn = fn (
                implementation: ?*const anyopaque,
                proxy: *Proxy,
                opcode: u32,
                message: *const Message,
                args: [*]Argument,
            ) callconv(.c) c_int;
            extern fn wl_proxy_add_dispatcher(
                proxy: *Proxy,
                dispatcher: *const DispatcherFn,
                implementation: ?*const anyopaque,
                data: ?*anyopaque,
            ) c_int;
            pub fn addDispatcher(
                proxy: *Proxy,
                dispatcher: *const DispatcherFn,
                implementation: ?*const anyopaque,
                data: ?*anyopaque,
            ) void {
                const ret = wl_proxy_add_dispatcher(proxy, dispatcher, implementation, data);
                // Since there is no way to remove listeners, adding a listener to
                // the same proxy twice is always a bug, so assert instead of returning
                // an error.
                assert(ret != -1); // If this fails, a listener was already added
            }

            extern fn wl_proxy_get_user_data(proxy: *Proxy) ?*anyopaque;
            pub const getUserData = wl_proxy_get_user_data;

            extern fn wl_proxy_get_version(proxy: *Proxy) u32;
            pub const getVersion = wl_proxy_get_version;

            extern fn wl_proxy_get_id(proxy: *Proxy) u32;
            pub const getId = wl_proxy_get_id;

            extern fn wl_proxy_set_queue(proxy: *Proxy, queue: *EventQueue) void;
            pub const setQueue = wl_proxy_set_queue;
        };

        pub const EventQueue = opaque {
            extern fn wl_event_queue_destroy(queue: *EventQueue) void;
            pub const destroy = wl_event_queue_destroy;
        };

        pub const EglWindow = opaque {
            extern fn wl_egl_window_create(surface: *client.wl.Surface, width: c_int, height: c_int) ?*EglWindow;
            pub fn create(surface: *client.wl.Surface, width: c_int, height: c_int) !*EglWindow {
                // Why do people use int when they require a positive number?
                assert(width > 0 and height > 0);
                return wl_egl_window_create(surface, width, height) orelse error.OutOfMemory;
            }

            extern fn wl_egl_window_destroy(egl_window: *EglWindow) void;
            pub const destroy = wl_egl_window_destroy;

            extern fn wl_egl_window_resize(egl_window: *EglWindow, width: c_int, height: c_int, dx: c_int, dy: c_int) void;
            pub const resize = wl_egl_window_resize;

            extern fn wl_egl_window_get_attached_size(egl_window: *EglWindow, width: *c_int, height: *c_int) void;
            pub const getAttachedSize = wl_egl_window_get_attached_size;
        };

        pub const CursorTheme = opaque {
            extern fn wl_cursor_theme_load(name: ?[*:0]const u8, size: c_int, shm: *client.wl.Shm) ?*CursorTheme;
            pub fn load(name: ?[*:0]const u8, size: i32, shm: *client.wl.Shm) error{LoadThemeFailed}!*CursorTheme {
                return wl_cursor_theme_load(name, @intCast(size), shm) orelse error.LoadThemeFailed;
            }

            extern fn wl_cursor_theme_destroy(wl_cursor_theme: *CursorTheme) void;
            pub const destroy = wl_cursor_theme_destroy;

            extern fn wl_cursor_theme_get_cursor(theme: *CursorTheme, name: [*:0]const u8) ?*Cursor;
            pub const getCursor = wl_cursor_theme_get_cursor;
        };

        pub const Cursor = extern struct {
            image_count: c_uint,
            images: [*]*CursorImage,
            name: [*:0]u8,

            extern fn wl_cursor_frame(cursor: *Cursor, time: u32) c_int;
            pub const frame = wl_cursor_frame;

            extern fn wl_cursor_frame_and_duration(cursor: *Cursor, time: u32, duration: *u32) c_int;
            pub const frameAndDuration = wl_cursor_frame_and_duration;
        };

        pub const CursorImage = extern struct {
            width: u32,
            height: u32,
            hotspot_x: u32,
            hotspot_y: u32,
            delay: u32,

            extern fn wl_cursor_image_get_buffer(image: *CursorImage) ?*client.wl.Buffer;
            pub fn getBuffer(image: *CursorImage) error{OutOfMemory}!*client.wl.Buffer {
                return wl_cursor_image_get_buffer(image) orelse error.OutOfMemory;
            }
        };

        /// The core global object.  This is a special singleton object.  It
        /// is used for internal Wayland protocol features.
        pub const Display = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.display.interface;
            pub const Error = common.wl.display.Error;
            pub fn getId(_display: *Display) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_display)).getId();
            }
            pub fn getVersion(_display: *Display) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_display)).getVersion();
            }
            pub fn getUserData(_display: *Display) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_display)).getUserData();
            }
            pub fn setQueue(_display: *Display, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// The error event is sent out when a fatal (non-recoverable)
                /// error has occurred.  The object_id argument is the object
                /// where the error occurred, most often in response to a request
                /// to that object.  The code identifies the error and is defined
                /// by the object interface.  As such, each interface defines its
                /// own set of error codes.  The message is a brief description
                /// of the error, for (debugging) convenience.
                @"error": struct {
                    object_id: ?*common.Object,
                    code: u32,
                    message: [*:0]const u8,
                },

                /// This event is used internally by the object ID management
                /// logic. When a client deletes an object that it had created,
                /// the server will send this event to acknowledge that it has
                /// seen the delete request. When the client receives this event,
                /// it will know that it can safely reuse the object ID.
                delete_id: struct {
                    id: u32,
                },
            };
            pub inline fn setListener(
                _display: *Display,
                comptime T: type,
                _listener: *const fn (display: *Display, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Display, T).dispatcher, _listener, _mut_data);
            }
            /// The sync request asks the server to emit the 'done' event
            /// on the returned wl_callback object.  Since requests are
            /// handled in-order and events are delivered in-order, this can
            /// be used as a barrier to ensure all previous requests and the
            /// resulting events have been handled.
            ///
            /// The object returned by this request will be destroyed by the
            /// compositor after the callback is fired and as such the client must not
            /// attempt to use it after that point.
            ///
            /// The callback_data passed in the callback is undefined and should be ignored.
            pub fn sync(_display: *Display) !*client.wl.Callback {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(0, &_args, client.wl.Callback.interface));
            }

            /// This request creates a registry object that allows the client
            /// to list and bind the global objects available from the
            /// compositor.
            ///
            /// It should be noted that the server side resources consumed in
            /// response to a get_registry request can only be released when the
            /// client disconnects, not when the client side proxy is destroyed.
            /// Therefore, clients should invoke get_registry as infrequently as
            /// possible to avoid wasting memory.
            pub fn getRegistry(_display: *Display) !*client.wl.Registry {
                const _proxy: *client.wl.Proxy = @ptrCast(_display);
                var _args = [_]common.Argument{
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructor(1, &_args, client.wl.Registry.interface));
            }
            extern fn wl_display_connect(name: ?[*:0]const u8) ?*Display;
            pub inline fn connect(name: ?[*:0]const u8) error{ConnectFailed}!*Display {
                return wl_display_connect(name) orelse return error.ConnectFailed;
            }

            extern fn wl_display_connect_to_fd(fd: c_int) ?*Display;
            pub inline fn connectToFd(fd: c_int) error{ConnectFailed}!*Display {
                return wl_display_connect_to_fd(fd) orelse return error.ConnectFailed;
            }

            extern fn wl_display_disconnect(display: *Display) void;
            pub const disconnect = wl_display_disconnect;

            extern fn wl_display_get_fd(display: *Display) c_int;
            pub const getFd = wl_display_get_fd;

            extern fn wl_display_dispatch(display: *Display) c_int;
            pub inline fn dispatch(display: *Display) posix.E {
                return posix.errno(wl_display_dispatch(display));
            }

            extern fn wl_display_dispatch_queue(display: *Display, queue: *client.wl.EventQueue) c_int;
            pub inline fn dispatchQueue(display: *Display, queue: *client.wl.EventQueue) posix.E {
                return posix.errno(wl_display_dispatch_queue(display, queue));
            }

            extern fn wl_display_dispatch_pending(display: *Display) c_int;
            pub inline fn dispatchPending(display: *Display) posix.E {
                return posix.errno(wl_display_dispatch_pending(display));
            }

            extern fn wl_display_dispatch_queue_pending(display: *Display, queue: *client.wl.EventQueue) c_int;
            pub inline fn dispatchQueuePending(display: *Display, queue: *client.wl.EventQueue) posix.E {
                return posix.errno(wl_display_dispatch_queue_pending(display, queue));
            }

            extern fn wl_display_roundtrip(display: *Display) c_int;
            pub inline fn roundtrip(display: *Display) posix.E {
                return posix.errno(wl_display_roundtrip(display));
            }

            extern fn wl_display_roundtrip_queue(display: *Display, queue: *client.wl.EventQueue) c_int;
            pub inline fn roundtripQueue(display: *Display, queue: *client.wl.EventQueue) posix.E {
                return posix.errno(wl_display_roundtrip_queue(display, queue));
            }

            extern fn wl_display_flush(display: *Display) c_int;
            pub inline fn flush(display: *Display) posix.E {
                return posix.errno(wl_display_flush(display));
            }

            extern fn wl_display_create_queue(display: *Display) ?*client.wl.EventQueue;
            pub inline fn createQueue(display: *Display) error{OutOfMemory}!*client.wl.EventQueue {
                return wl_display_create_queue(display) orelse error.OutOfMemory;
            }

            extern fn wl_display_get_error(display: *Display) c_int;
            pub const getError = wl_display_get_error;

            extern fn wl_display_prepare_read_queue(display: *Display, queue: *client.wl.EventQueue) c_int;
            /// Succeeds if the queue is empty and returns true.
            /// Fails and returns false if the queue was not empty.
            pub inline fn prepareReadQueue(display: *Display, queue: *client.wl.EventQueue) bool {
                switch (wl_display_prepare_read_queue(display, queue)) {
                    0 => return true,
                    -1 => return false,
                    else => unreachable,
                }
            }

            extern fn wl_display_prepare_read(display: *Display) c_int;
            /// Succeeds if the queue is empty and returns true.
            /// Fails and returns false if the queue was not empty.
            pub inline fn prepareRead(display: *Display) bool {
                switch (wl_display_prepare_read(display)) {
                    0 => return true,
                    -1 => return false,
                    else => unreachable,
                }
            }

            extern fn wl_display_cancel_read(display: *Display) void;
            pub const cancelRead = wl_display_cancel_read;

            extern fn wl_display_read_events(display: *Display) c_int;
            pub inline fn readEvents(display: *Display) posix.E {
                return posix.errno(wl_display_read_events(display));
            }
        };

        /// The singleton global registry object.  The server has a number of
        /// global objects that are available to all clients.  These objects
        /// typically represent an actual object in the server (for example,
        /// an input device) or they are singleton objects that provide
        /// extension functionality.
        ///
        /// When a client creates a registry object, the registry object
        /// will emit a global event for each global currently in the
        /// registry.  Globals come and go as a result of device or
        /// monitor hotplugs, reconfiguration or other events, and the
        /// registry will send out global and global_remove events to
        /// keep the client up to date with the changes.  To mark the end
        /// of the initial burst of events, the client can use the
        /// wl_display.sync request immediately after calling
        /// wl_display.get_registry.
        ///
        /// A client can bind to a global object by using the bind
        /// request.  This creates a client-side handle that lets the object
        /// emit events to the client and lets the client invoke requests on
        /// the object.
        pub const Registry = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.registry.interface;
            pub fn getId(_registry: *Registry) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_registry)).getId();
            }
            pub fn getVersion(_registry: *Registry) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_registry)).getVersion();
            }
            pub fn getUserData(_registry: *Registry) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_registry)).getUserData();
            }
            pub fn setQueue(_registry: *Registry, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Notify the client of global objects.
                ///
                /// The event notifies the client that a global object with
                /// the given name is now available, and it implements the
                /// given version of the given interface.
                global: struct {
                    name: u32,
                    interface: [*:0]const u8,
                    version: u32,
                },

                /// Notify the client of removed global objects.
                ///
                /// This event notifies the client that the global identified
                /// by name is no longer available.  If the client bound to
                /// the global using the bind request, the client should now
                /// destroy that object.
                ///
                /// The object remains valid and requests to the object will be
                /// ignored until the client destroys it, to avoid races between
                /// the global going away and a client sending a request to it.
                global_remove: struct {
                    name: u32,
                },
            };
            pub inline fn setListener(
                _registry: *Registry,
                comptime T: type,
                _listener: *const fn (registry: *Registry, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Registry, T).dispatcher, _listener, _mut_data);
            }
            /// Binds a new, client-created object to the server using the
            /// specified name as the identifier.
            pub fn bind(_registry: *Registry, _name: u32, comptime T: type, _version: u32) !*T {
                const version_to_construct = @min(T.generated_version, _version);
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                var _args = [_]common.Argument{
                    .{ .u = _name },
                    .{ .s = T.interface.name },
                    .{ .u = version_to_construct },
                    .{ .o = null },
                };
                return @ptrCast(try _proxy.marshalConstructorVersioned(0, &_args, T.interface, version_to_construct));
            }
            pub fn destroy(_registry: *Registry) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_registry);
                _proxy.destroy();
            }
        };

        /// Clients can handle the 'done' event to get notified when
        /// the related request is done.
        ///
        /// Note, because wl_callback objects are created from multiple independent
        /// factory interfaces, the wl_callback interface is frozen at version 1.
        pub const Callback = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.callback.interface;
            pub fn getId(_callback: *Callback) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_callback)).getId();
            }
            pub fn getVersion(_callback: *Callback) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_callback)).getVersion();
            }
            pub fn getUserData(_callback: *Callback) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_callback)).getUserData();
            }
            pub fn setQueue(_callback: *Callback, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_callback);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Notify the client when the related request is done.
                done: struct {
                    callback_data: u32,
                },
            };
            pub inline fn setListener(
                _callback: *Callback,
                comptime T: type,
                _listener: *const fn (callback: *Callback, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_callback);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Callback, T).dispatcher, _listener, _mut_data);
            }
            pub fn destroy(_callback: *Callback) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_callback);
                _proxy.destroy();
            }
        };

        /// A buffer provides the content for a wl_surface. Buffers are
        /// created through factory interfaces such as wl_shm, wp_linux_buffer_params
        /// (from the linux-dmabuf protocol extension) or similar. It has a width and
        /// a height and can be attached to a wl_surface, but the mechanism by which a
        /// client provides and updates the contents is defined by the buffer factory
        /// interface.
        ///
        /// Color channels are assumed to be electrical rather than optical (in other
        /// words, encoded with a transfer function) unless otherwise specified. If
        /// the buffer uses a format that has an alpha channel, the alpha channel is
        /// assumed to be premultiplied into the electrical color channel values
        /// (after transfer function encoding) unless otherwise specified.
        ///
        /// Note, because wl_buffer objects are created from multiple independent
        /// factory interfaces, the wl_buffer interface is frozen at version 1.
        pub const Buffer = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.buffer.interface;
            pub fn getId(_buffer: *Buffer) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_buffer)).getId();
            }
            pub fn getVersion(_buffer: *Buffer) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_buffer)).getVersion();
            }
            pub fn getUserData(_buffer: *Buffer) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_buffer)).getUserData();
            }
            pub fn setQueue(_buffer: *Buffer, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_buffer);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// Sent when this wl_buffer is no longer used by the compositor.
                ///
                /// For more information on when release events may or may not be sent,
                /// and what consequences it has, please see the description of
                /// wl_surface.attach.
                ///
                /// If a client receives a release event before the frame callback
                /// requested in the same wl_surface.commit that attaches this
                /// wl_buffer to a surface, then the client is immediately free to
                /// reuse the buffer and its backing storage, and does not need a
                /// second buffer for the next surface content update. Typically
                /// this is possible, when the compositor maintains a copy of the
                /// wl_surface contents, e.g. as a GL texture. This is an important
                /// optimization for GL(ES) compositors with wl_shm clients.
                release: void,
            };
            pub inline fn setListener(
                _buffer: *Buffer,
                comptime T: type,
                _listener: *const fn (buffer: *Buffer, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_buffer);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(Buffer, T).dispatcher, _listener, _mut_data);
            }
            /// Destroy a buffer. If and how you need to release the backing
            /// storage is defined by the buffer factory interface.
            ///
            /// For possible side-effects to a surface, see wl_surface.attach.
            pub fn destroy(_buffer: *Buffer) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_buffer);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }
        };
    };
    pub const river = struct {
        /// A global factory for river_layout_v3 objects.
        pub const LayoutManagerV3 = opaque {
            pub const generated_version = 2;
            pub const interface = &common.river.layout_manager_v3.interface;
            pub fn getId(_layout_manager_v3: *LayoutManagerV3) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_layout_manager_v3)).getId();
            }
            pub fn getVersion(_layout_manager_v3: *LayoutManagerV3) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_layout_manager_v3)).getVersion();
            }
            pub fn getUserData(_layout_manager_v3: *LayoutManagerV3) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_layout_manager_v3)).getUserData();
            }
            pub fn setQueue(_layout_manager_v3: *LayoutManagerV3, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_layout_manager_v3);
                _proxy.setQueue(_queue);
            }
            /// This request indicates that the client will not use the
            /// river_layout_manager object any more. Objects that have been created
            /// through this instance are not affected.
            pub fn destroy(_layout_manager_v3: *LayoutManagerV3) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_layout_manager_v3);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }

            /// This creates a new river_layout_v3 object for the given wl_output.
            ///
            /// All layout related communication is done through this interface.
            ///
            /// The namespace is used by the compositor to decide which river_layout_v3
            /// object will receive layout demands for the output.
            ///
            /// The namespace is required to be be unique per-output. Furthermore,
            /// two separate clients may not share a namespace on separate outputs. If
            /// these conditions are not upheld, the the namespace_in_use event will
            /// be sent directly after creation of the river_layout_v3 object.
            pub fn getLayout(_layout_manager_v3: *LayoutManagerV3, _output: *client.wl.Output, _namespace: [*:0]const u8) !*client.river.LayoutV3 {
                const _proxy: *client.wl.Proxy = @ptrCast(_layout_manager_v3);
                var _args = [_]common.Argument{
                    .{ .o = null },
                    .{ .o = @ptrCast(_output) },
                    .{ .s = _namespace },
                };
                return @ptrCast(try _proxy.marshalConstructor(1, &_args, client.river.LayoutV3.interface));
            }
        };

        /// This interface allows clients to receive layout demands from the
        /// compositor for a specific output and subsequently propose positions and
        /// dimensions of individual views.
        pub const LayoutV3 = opaque {
            pub const generated_version = 2;
            pub const interface = &common.river.layout_v3.interface;
            pub const Error = common.river.layout_v3.Error;
            pub fn getId(_layout_v3: *LayoutV3) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_layout_v3)).getId();
            }
            pub fn getVersion(_layout_v3: *LayoutV3) u32 {
                return @as(*client.wl.Proxy, @ptrCast(_layout_v3)).getVersion();
            }
            pub fn getUserData(_layout_v3: *LayoutV3) ?*anyopaque {
                return @as(*client.wl.Proxy, @ptrCast(_layout_v3)).getUserData();
            }
            pub fn setQueue(_layout_v3: *LayoutV3, _queue: *client.wl.EventQueue) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_layout_v3);
                _proxy.setQueue(_queue);
            }
            pub const Event = union(enum) {
                /// After this event is sent, all requests aside from the destroy event
                /// will be ignored by the server. If the client wishes to try again with
                /// a different namespace they must create a new river_layout_v3 object.
                namespace_in_use: void,
                /// The compositor sends this event to inform the client that it requires a
                /// layout for a set of views.
                ///
                /// The usable width and height indicate the space in which the client
                /// can safely position views without interfering with desktop widgets
                /// such as panels.
                ///
                /// The serial of this event is used to identify subsequent requests as
                /// belonging to this layout demand. Beware that the client might need
                /// to handle multiple layout demands at the same time.
                ///
                /// The server will ignore responses to all but the most recent layout
                /// demand. Thus, clients are only required to respond to the most recent
                /// layout_demand received. If a newer layout_demand is received before
                /// the client has finished responding to an old demand, the client should
                /// abort work on the old demand as any further work would be wasted.
                layout_demand: struct {
                    view_count: u32,
                    usable_width: u32,
                    usable_height: u32,
                    tags: u32,
                    serial: u32,
                },

                /// This event informs the client of a command sent to it by the user.
                ///
                /// The semantic meaning of the command is left for the client to
                /// decide. It is also free to ignore it entirely if it so chooses.
                ///
                /// A layout_demand will be sent after this event if the compositor is
                /// currently using this layout object to arrange the output.
                ///
                /// If version 2 or higher of the river_layout_v3 object is bound, the
                /// user_command_tags event is guaranteed to be sent directly before the
                /// user_command event.
                user_command: struct {
                    command: [*:0]const u8,
                },

                /// If version 2 or higher of the river_layout_v3 object is bound, this
                /// event will be sent directly before every user_command event. This allows
                /// layout generators to be aware of the active tags when a user command is
                /// sent. This is necessary for generators wanting to keep settings on a
                /// per-tag basis.
                user_command_tags: struct {
                    tags: u32,
                },
            };
            pub inline fn setListener(
                _layout_v3: *LayoutV3,
                comptime T: type,
                _listener: *const fn (layout_v3: *LayoutV3, event: Event, data: T) void,
                _data: T,
            ) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_layout_v3);
                const _mut_data: ?*anyopaque = @ptrFromInt(@intFromPtr(_data));
                _proxy.addDispatcher(common.Dispatcher(LayoutV3, T).dispatcher, _listener, _mut_data);
            }
            /// This request indicates that the client will not use the river_layout_v3
            /// object any more.
            pub fn destroy(_layout_v3: *LayoutV3) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_layout_v3);
                _proxy.marshal(0, null);
                _proxy.destroy();
            }

            /// This request proposes a size and position for a view in the layout demand
            /// with matching serial.
            ///
            /// A client must send this request for every view that is part of the
            /// layout demand. The number of views in the layout is given by the
            /// view_count argument of the layout_demand event. Pushing too many or
            /// too few view dimensions is a protocol error.
            ///
            /// The x and y coordinates are relative to the usable area of the output,
            /// with (0,0) as the top left corner.
            pub fn pushViewDimensions(_layout_v3: *LayoutV3, _x: i32, _y: i32, _width: u32, _height: u32, _serial: u32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_layout_v3);
                var _args = [_]common.Argument{
                    .{ .i = _x },
                    .{ .i = _y },
                    .{ .u = _width },
                    .{ .u = _height },
                    .{ .u = _serial },
                };
                _proxy.marshal(1, &_args);
            }

            /// This request indicates that the client is done pushing dimensions
            /// and the compositor may apply the layout. This completes the layout
            /// demand with matching serial, any other requests sent with the serial
            /// are a protocol error.
            ///
            /// The layout_name argument is a user-facing name or short description
            /// of the layout that is being committed. The compositor may for example
            /// display this on a status bar, though what exactly is done with it is
            /// left to the compositor's discretion.
            ///
            /// The compositor is free to use this proposed layout however it chooses,
            /// including ignoring it.
            pub fn commit(_layout_v3: *LayoutV3, _layout_name: [*:0]const u8, _serial: u32) void {
                const _proxy: *client.wl.Proxy = @ptrCast(_layout_v3);
                var _args = [_]common.Argument{
                    .{ .s = _layout_name },
                    .{ .u = _serial },
                };
                _proxy.marshal(2, &_args);
            }
        };
    };
};

pub const server = struct {
    pub const wl = struct {
        pub const Object = common.Object;
        pub const Message = common.Message;
        pub const Interface = common.Interface;
        pub const list = common.list;
        pub const Array = common.Array;
        pub const Fixed = common.Fixed;
        pub const Argument = common.Argument;

        /// This is wayland-server's wl_display. It has been renamed as zig-wayland has
        /// decided to hide wl_resources with opaque pointers in the same way that
        /// wayland-client does with wl_proxys. This of course creates a name conflict.
        pub const Server = opaque {
            extern fn wl_display_create() ?*Server;
            pub fn create() !*Server {
                return wl_display_create() orelse error.ServerCreateFailed;
            }

            extern fn wl_display_destroy(server: *Server) void;
            pub const destroy = wl_display_destroy;

            extern fn wl_display_get_event_loop(server: *Server) *EventLoop;
            pub const getEventLoop = wl_display_get_event_loop;

            extern fn wl_display_add_socket(server: *Server, name: [*:0]const u8) c_int;
            pub fn addSocket(_server: *Server, name: [*:0]const u8) !void {
                if (wl_display_add_socket(_server, name) == -1)
                    return error.AddSocketFailed;
            }

            // wayland-client will connect to wayland-0 even if WAYLAND_DISPLAY is
            // unset due to an unfortunate piece of code that was not removed before
            // the library was stabilized. Because of this, it is a good idea to never
            // call the socket wayland-0. So, instead of binding to wayland-server's
            // wl_display_add_socket_auto we implement a version which skips wayland-0.
            pub fn addSocketAuto(_server: *Server, buf: *[11]u8) ![:0]const u8 {
                // Don't use wayland-0
                var i: u32 = 1;
                while (i <= 32) : (i += 1) {
                    const name = std.fmt.bufPrintZ(buf, "wayland-{}", .{i}) catch unreachable;
                    _server.addSocket(name.ptr) catch continue;
                    return name;
                }
                return error.AddSocketFailed;
            }

            extern fn wl_display_add_socket_fd(_server: *Server, sock_fd: c_int) c_int;
            pub fn addSocketFd(_server: *Server, sock_fd: c_int) !void {
                if (wl_display_add_socket_fd(_server, sock_fd) == -1)
                    return error.AddSocketFailed;
            }

            extern fn wl_display_terminate(_server: *Server) void;
            pub const terminate = wl_display_terminate;

            extern fn wl_display_run(_server: *Server) void;
            pub const run = wl_display_run;

            extern fn wl_display_flush_clients(_server: *Server) void;
            pub const flushClients = wl_display_flush_clients;

            extern fn wl_display_destroy_clients(_server: *Server) void;
            pub const destroyClients = wl_display_destroy_clients;

            extern fn wl_display_get_serial(_server: *Server) u32;
            pub const getSerial = wl_display_get_serial;

            extern fn wl_display_next_serial(_server: *Server) u32;
            pub const nextSerial = wl_display_next_serial;

            extern fn wl_display_add_destroy_listener(_server: *Server, listener: *Listener(*Server)) void;
            pub const addDestroyListener = wl_display_add_destroy_listener;

            extern fn wl_display_add_client_created_listener(_server: *Server, listener: *Listener(*Client)) void;
            pub const addClientCreatedListener = wl_display_add_client_created_listener;

            // Doesn't really make sense with our Listener API as we would need to
            // pass a pointer to the wrapper function
            //extern fn wl_display_get_destroy_listener(_server: *Server, notify: @TypeOf(Listener(*Server).notify)) ?*Listener(*Server);

            extern fn wl_display_set_global_filter(
                _server: *Server,
                filter: *const fn (_client: *const Client, global: *const Global, data: ?*anyopaque) callconv(.c) bool,
                data: ?*anyopaque,
            ) void;
            pub inline fn setGlobalFilter(
                _server: *Server,
                comptime T: type,
                comptime filter: fn (_client: *const Client, global: *const Global, data: T) bool,
                data: T,
            ) void {
                wl_display_set_global_filter(
                    _server,
                    struct {
                        fn _wrapper(_client: *const Client, _global: *const Global, _data: ?*anyopaque) callconv(.c) bool {
                            return filter(_client, _global, @ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                );
            }

            extern fn wl_display_get_client_list(_server: *Server) *list.Head(Client, null);
            pub const getClientList = wl_display_get_client_list;

            extern fn wl_display_init_shm(_server: *Server) c_int;
            pub fn initShm(_server: *Server) !void {
                if (wl_display_init_shm(_server) == -1) return error.OutOfMemory;
            }

            extern fn wl_display_add_shm_format(_server: *Server, format: u32) ?*u32;
            pub fn addShmFormat(_server: *Server, format: u32) !*u32 {
                return wl_display_add_shm_format(_server, format) orelse error.OutOfMemory;
            }

            extern fn wl_display_add_protocol_logger(
                _server: *Server,
                func: *const fn (data: ?*anyopaque, direction: ProtocolLogger.Type, message: *const ProtocolLogger.LogMessage) callconv(.c) void,
                data: ?*anyopaque,
            ) void;
            pub inline fn addProtocolLogger(
                _server: *Server,
                comptime T: type,
                comptime func: fn (data: T, direction: ProtocolLogger.Type, message: *const ProtocolLogger.LogMessage) void,
                data: T,
            ) void {
                wl_display_add_protocol_logger(
                    _server,
                    struct {
                        fn _wrapper(_data: ?*anyopaque, _direction: ProtocolLogger.Type, _message: *const ProtocolLogger.LogMessage) callconv(.c) void {
                            func(@ptrCast(@alignCast(_data)), _direction, _message);
                        }
                    }._wrapper,
                    data,
                );
            }
        };

        pub const Client = opaque {
            extern fn wl_client_create(_server: *Server, fd: c_int) ?*Client;
            pub const create = wl_client_create;

            extern fn wl_client_destroy(_client: *Client) void;
            pub const destroy = wl_client_destroy;

            extern fn wl_client_flush(_client: *Client) void;
            pub const flush = wl_client_flush;

            extern fn wl_client_get_link(_client: *Client) *list.Link;
            pub const getLink = wl_client_get_link;

            extern fn wl_client_from_link(link: *list.Link) *Client;
            pub const fromLink = wl_client_from_link;

            const Credentials = struct {
                pid: posix.pid_t,
                gid: posix.gid_t,
                uid: posix.uid_t,
            };
            extern fn wl_client_get_credentials(_client: *Client, pid: *posix.pid_t, uid: *posix.uid_t, gid: *posix.gid_t) void;
            pub fn getCredentials(_client: *Client) Credentials {
                var credentials: Credentials = undefined;
                wl_client_get_credentials(_client, &credentials.pid, &credentials.uid, &credentials.gid);
                return credentials;
            }

            extern fn wl_client_add_destroy_listener(_client: *Client, listener: *Listener(*Client)) void;
            pub const addDestroyListener = wl_client_add_destroy_listener;

            // Doesn't really make sense with our Listener API as we would need to
            // pass a pointer to the wrapper function
            //extern fn wl_client_get_destroy_listener(_client: *Client, notify: @TypeOf(Listener(*Client).notify)) ?*Listener(*Client);

            extern fn wl_client_get_object(_client: *Client, id: u32) ?*Resource;
            pub const getObject = wl_client_get_object;

            extern fn wl_client_post_no_memory(_client: *Client) void;
            pub const postNoMemory = wl_client_post_no_memory;

            extern fn wl_client_post_implementation_error(_client: *Client, msg: [*:0]const u8, ...) void;
            pub const postImplementationError = wl_client_post_implementation_error;

            extern fn wl_client_add_resource_created_listener(_client: *Client, listener: *Listener(*Resource)) void;
            pub const addResourceCreatedListener = wl_client_add_resource_created_listener;

            const IteratorResult = enum(c_int) { stop, cont };
            extern fn wl_client_for_each_resource(
                _client: *Client,
                iterator: *const fn (resource: *Resource, data: ?*anyopaque) callconv(.c) IteratorResult,
                data: ?*anyopaque,
            ) void;
            pub inline fn forEachResource(
                _client: *Client,
                comptime T: type,
                comptime iterator: fn (resource: *Resource, data: T) IteratorResult,
                data: T,
            ) void {
                wl_client_for_each_resource(
                    _client,
                    struct {
                        fn _wrapper(_resource: *Resource, _data: ?*anyopaque) callconv(.c) IteratorResult {
                            return iterator(_resource, @ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                );
            }

            extern fn wl_client_get_fd(_client: *Client) c_int;
            pub const getFd = wl_client_get_fd;

            extern fn wl_client_get_display(_client: *Client) *Server;
            pub const getDisplay = wl_client_get_display;
        };

        pub const Global = opaque {
            extern fn wl_global_create(
                _server: *Server,
                interface: *const Interface,
                version: c_int,
                data: ?*anyopaque,
                bind: *const fn (_client: *Client, data: ?*anyopaque, version: u32, id: u32) callconv(.c) void,
            ) ?*Global;
            pub inline fn create(
                _server: *Server,
                comptime T: type,
                version: u32,
                comptime DataT: type,
                data: DataT,
                comptime bind: fn (_client: *Client, data: DataT, version: u32, id: u32) void,
            ) error{GlobalCreateFailed}!*Global {
                return wl_global_create(
                    _server,
                    T.interface,
                    @as(c_int, @intCast(version)),
                    data,
                    struct {
                        fn _wrapper(_client: *Client, _data: ?*anyopaque, _version: u32, _id: u32) callconv(.c) void {
                            bind(_client, @ptrCast(@alignCast(_data)), _version, _id);
                        }
                    }._wrapper,
                ) orelse error.GlobalCreateFailed;
            }

            extern fn wl_global_remove(global: *Global) void;
            pub const remove = wl_global_remove;

            extern fn wl_global_destroy(global: *Global) void;
            pub const destroy = wl_global_destroy;

            extern fn wl_global_get_interface(global: *const Global) *const Interface;
            pub const getInterface = wl_global_get_interface;

            extern fn wl_global_get_name(global: *const Global, _client: *const Client) u32;
            pub const getName = wl_global_get_name;

            extern fn wl_global_get_user_data(global: *const Global) ?*anyopaque;
            pub const getUserData = wl_global_get_user_data;
        };

        pub const Resource = opaque {
            extern fn wl_resource_create(_client: *Client, interface: *const Interface, version: c_int, id: u32) ?*Resource;
            pub inline fn create(_client: *Client, comptime T: type, version: u32, id: u32) error{ResourceCreateFailed}!*Resource {
                // This is only a c_int because of legacy libwayland reasons. Negative versions are invalid.
                // Version is a u32 on the wire and for wl_global, wl_proxy, etc.
                return wl_resource_create(_client, T.interface, @as(c_int, @intCast(version)), id) orelse error.ResourceCreateFailed;
            }

            extern fn wl_resource_destroy(resource: *Resource) void;
            pub const destroy = wl_resource_destroy;

            extern fn wl_resource_post_event_array(resource: *Resource, opcode: u32, args: ?[*]Argument) void;
            pub const postEvent = wl_resource_post_event_array;

            extern fn wl_resource_queue_event_array(resource: *Resource, opcode: u32, args: ?[*]Argument) void;
            pub const queueEvent = wl_resource_queue_event_array;

            extern fn wl_resource_post_error(resource: *Resource, code: u32, message: [*:0]const u8, ...) void;
            pub const postError = wl_resource_post_error;

            extern fn wl_resource_post_no_memory(resource: *Resource) void;
            pub const postNoMemory = wl_resource_post_no_memory;

            const DispatcherFn = fn (
                implementation: ?*const anyopaque,
                resource: *Resource,
                opcode: u32,
                message: *const Message,
                args: [*]Argument,
            ) callconv(.c) c_int;
            pub const DestroyFn = fn (resource: *Resource) callconv(.c) void;
            extern fn wl_resource_set_dispatcher(
                resource: *Resource,
                dispatcher: ?*const DispatcherFn,
                implementation: ?*const anyopaque,
                data: ?*anyopaque,
                destroy_fn: ?*const DestroyFn,
            ) void;
            pub fn setDispatcher(
                resource: *Resource,
                dispatcher: ?*const DispatcherFn,
                implementation: ?*const anyopaque,
                data: ?*anyopaque,
                destroy_fn: ?*const DestroyFn,
            ) void {
                wl_resource_set_dispatcher(resource, dispatcher, implementation, data, destroy_fn);
            }

            extern fn wl_resource_get_user_data(resource: *Resource) ?*anyopaque;
            pub const getUserData = wl_resource_get_user_data;

            extern fn wl_resource_get_id(resource: *Resource) u32;
            pub const getId = wl_resource_get_id;

            extern fn wl_resource_get_link(resource: *Resource) *list.Link;
            pub const getLink = wl_resource_get_link;

            extern fn wl_resource_from_link(link: *list.Link) *Resource;
            pub const fromLink = wl_resource_from_link;

            extern fn wl_resource_find_for_client(list: *list.Head(Resource, null), _client: *Client) ?*Resource;
            pub const findForClient = wl_resource_find_for_client;

            extern fn wl_resource_get_client(resource: *Resource) *Client;
            pub const getClient = wl_resource_get_client;

            extern fn wl_resource_get_version(resource: *Resource) c_int;
            pub fn getVersion(resource: *Resource) u32 {
                // The fact that wl_resource.version is a int in libwayland is
                // a mistake. Negative versions are impossible and u32 is used
                // everywhere else in libwayland
                return @as(u32, @intCast(wl_resource_get_version(resource)));
            }

            // TOOD: unsure if this should be bound
            extern fn wl_resource_set_destructor(resource: *Resource, destroy: DestroyFn) void;

            extern fn wl_resource_get_class(resource: *Resource) [*:0]const u8;
            pub const getClass = wl_resource_get_class;

            extern fn wl_resource_add_destroy_listener(resource: *Resource, listener: *Listener(*Resource)) void;
            pub const addDestroyListener = wl_resource_add_destroy_listener;

            // Doesn't really make sense with our Listener API as we would need to
            // pass a pointer to the wrapper function
            //extern fn wl_resource_get_destroy_listener(resource: *Resource, notify: @TypeOf(Listener(*Resource).notify)) ?*Listener(*Resource);
        };

        pub const ProtocolLogger = opaque {
            pub const Type = enum(c_int) {
                request,
                event,
            };

            pub const LogMessage = extern struct {
                resource: *Resource,
                message_opcode: c_int,
                message: *Message,
                arguments_count: c_int,
                arguments: ?[*]Argument,
            };

            extern fn wl_protocol_logger_destroy(logger: *ProtocolLogger) void;
            pub const destroy = wl_protocol_logger_destroy;
        };

        pub fn Listener(comptime T: type) type {
            return extern struct {
                const Self = @This();

                pub const NotifyFn = if (T == void)
                    fn (listener: *Self) void
                else
                    fn (listener: *Self, data: T) void;

                link: list.Link,
                notify: *const fn (listener: *Self, data: ?*anyopaque) callconv(.c) void,

                pub fn init(comptime notify: NotifyFn) Self {
                    var self: Self = undefined;
                    self.setNotify(notify);
                    return self;
                }

                pub fn setNotify(self: *Self, comptime notify: NotifyFn) void {
                    self.notify = if (T == void)
                        struct {
                            fn wrapper(listener: *Self, _: ?*anyopaque) callconv(.c) void {
                                @call(.always_inline, notify, .{listener});
                            }
                        }.wrapper
                    else
                        struct {
                            fn wrapper(listener: *Self, data: ?*anyopaque) callconv(.c) void {
                                @call(.always_inline, notify, .{ listener, @as(T, @ptrFromInt(@intFromPtr(data))) });
                            }
                        }.wrapper;
                }
            };
        }

        pub fn Signal(comptime T: type) type {
            return extern struct {
                const Self = @This();

                listener_list: list.Head(Listener(T), .link),

                pub fn init(signal: *Self) void {
                    signal.listener_list.init();
                }

                pub fn add(signal: *Self, listener: *Listener(T)) void {
                    signal.listener_list.append(listener);
                }

                pub fn get(signal: *Self, notify: @TypeOf(Listener(T).notify)) ?*Listener(T) {
                    var it = signal.listener_list.iterator(.forward);
                    return while (it.next()) |listener| {
                        if (listener.notify == notify) break listener;
                    } else null;
                }

                pub const emit = if (T == void)
                    struct {
                        pub inline fn emit(signal: *Self) void {
                            emitInner(signal, null);
                        }
                    }.emit
                else
                    struct {
                        pub inline fn emit(signal: *Self, data: T) void {
                            emitInner(signal, data);
                        }
                    }.emit;

                /// This is similar to wlroots' wlr_signal_emit_safe. It handles
                /// removal of any element in the list during iteration and stops at
                /// whatever the last element was when iteration started.
                fn emitInner(signal: *Self, data: ?*anyopaque) void {
                    var cursor: Listener(T) = undefined;
                    signal.listener_list.prepend(&cursor);

                    var end: Listener(T) = undefined;
                    signal.listener_list.append(&end);

                    while (cursor.link.next != &end.link) {
                        const pos = cursor.link.next.?;
                        const listener: *Listener(T) = @fieldParentPtr("link", pos);

                        cursor.link.remove();
                        pos.insert(&cursor.link);

                        listener.notify(listener, data);
                    }

                    cursor.link.remove();
                    end.link.remove();
                }
            };
        }

        pub const EventMask = packed struct(u32) {
            readable: bool = false,
            writable: bool = false,
            hangup: bool = false,
            @"error": bool = false,

            _: u28 = 0,
        };

        pub const EventLoop = opaque {
            extern fn wl_event_loop_create() ?*EventLoop;
            pub fn create() !*EventLoop {
                return wl_event_loop_create() orelse error.EventLoopCreateFailed;
            }

            extern fn wl_event_loop_destroy(loop: *EventLoop) void;
            pub const destroy = wl_event_loop_destroy;

            extern fn wl_event_loop_add_fd(
                loop: *EventLoop,
                fd: c_int,
                mask: u32,
                func: *const fn (fd: c_int, mask: u32, data: ?*anyopaque) callconv(.c) c_int,
                data: ?*anyopaque,
            ) ?*EventSource;
            pub inline fn addFd(
                loop: *EventLoop,
                comptime T: type,
                fd: c_int,
                mask: EventMask,
                comptime func: fn (fd: c_int, mask: EventMask, data: T) c_int,
                data: T,
            ) error{AddFdFailed}!*EventSource {
                return wl_event_loop_add_fd(
                    loop,
                    fd,
                    mask,
                    struct {
                        fn _wrapper(_fd: c_int, _mask: u32, _data: ?*anyopaque) callconv(.c) c_int {
                            return func(_fd, @bitCast(_mask), @ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                ) orelse error.AddFdFailed;
            }

            extern fn wl_event_loop_add_timer(
                loop: *EventLoop,
                func: *const fn (data: ?*anyopaque) callconv(.c) c_int,
                data: ?*anyopaque,
            ) ?*EventSource;
            pub inline fn addTimer(
                loop: *EventLoop,
                comptime T: type,
                comptime func: fn (data: T) c_int,
                data: T,
            ) error{AddTimerFailed}!*EventSource {
                return wl_event_loop_add_timer(
                    loop,
                    struct {
                        fn _wrapper(_data: ?*anyopaque) callconv(.c) c_int {
                            return func(@ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                ) orelse error.AddTimerFailed;
            }

            extern fn wl_event_loop_add_signal(
                loop: *EventLoop,
                signal_number: c_int,
                func: *const fn (c_int, ?*anyopaque) callconv(.c) c_int,
                data: ?*anyopaque,
            ) ?*EventSource;
            pub inline fn addSignal(
                loop: *EventLoop,
                comptime T: type,
                signal_number: c_int,
                comptime func: fn (signal_number: c_int, data: T) c_int,
                data: T,
            ) error{AddSignalFailed}!*EventSource {
                return wl_event_loop_add_signal(
                    loop,
                    signal_number,
                    struct {
                        fn _wrapper(_signal_number: c_int, _data: ?*anyopaque) callconv(.c) c_int {
                            return func(_signal_number, @ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                ) orelse error.AddSignalFailed;
            }

            extern fn wl_event_loop_add_idle(
                loop: *EventLoop,
                func: *const fn (data: ?*anyopaque) callconv(.c) void,
                data: ?*anyopaque,
            ) ?*EventSource;
            pub inline fn addIdle(
                loop: *EventLoop,
                comptime T: type,
                comptime func: fn (data: T) void,
                data: T,
            ) error{OutOfMemory}!*EventSource {
                return wl_event_loop_add_idle(
                    loop,
                    struct {
                        fn _wrapper(_data: ?*anyopaque) callconv(.c) void {
                            return func(@ptrCast(@alignCast(_data)));
                        }
                    }._wrapper,
                    data,
                ) orelse error.OutOfMemory;
            }

            extern fn wl_event_loop_dispatch(loop: *EventLoop, timeout: c_int) c_int;
            pub fn dispatch(loop: *EventLoop, timeout: c_int) !void {
                const rc = wl_event_loop_dispatch(loop, timeout);
                switch (posix.errno(rc)) {
                    .SUCCESS => return,
                    // TODO
                    else => |err| return posix.unexpectedErrno(err),
                }
            }

            extern fn wl_event_loop_dispatch_idle(loop: *EventLoop) void;
            pub const dispatchIdle = wl_event_loop_dispatch_idle;

            extern fn wl_event_loop_get_fd(loop: *EventLoop) c_int;
            pub const getFd = wl_event_loop_get_fd;

            extern fn wl_event_loop_add_destroy_listener(loop: *EventLoop, listener: *Listener(*EventLoop)) void;
            pub const addDestroyListener = wl_event_loop_add_destroy_listener;

            //extern fn wl_event_loop_get_destroy_listener(loop: *EventLoop, notify: @TypeOf(Listener(*EventLoop).notify)) ?*Listener;
            //pub const getDestroyListener = wl_event_loop_get_destroy_listener;
        };

        pub const EventSource = opaque {
            extern fn wl_event_source_remove(source: *EventSource) c_int;
            pub fn remove(source: *EventSource) void {
                if (wl_event_source_remove(source) != 0) unreachable;
            }

            extern fn wl_event_source_check(source: *EventSource) void;
            pub const check = wl_event_source_check;

            extern fn wl_event_source_fd_update(source: *EventSource, mask: u32) c_int;
            pub fn fdUpdate(source: *EventSource, mask: EventMask) !void {
                const rc = wl_event_source_fd_update(source, @bitCast(mask));
                switch (posix.errno(rc)) {
                    .SUCCESS => return,
                    // TODO
                    else => |err| return posix.unexpectedErrno(err),
                }
            }

            extern fn wl_event_source_timer_update(source: *EventSource, ms_delay: c_int) c_int;
            pub fn timerUpdate(source: *EventSource, ms_delay: c_int) !void {
                const rc = wl_event_source_timer_update(source, ms_delay);
                switch (posix.errno(rc)) {
                    .SUCCESS => return,
                    // TODO
                    else => |err| return posix.unexpectedErrno(err),
                }
            }
        };

        pub const shm = struct {
            pub const Buffer = opaque {
                extern fn wl_shm_buffer_get(resource: *Resource) ?*shm.Buffer;
                pub const get = wl_shm_buffer_get;

                extern fn wl_shm_buffer_begin_access(buffer: *shm.Buffer) void;
                pub const beginAccess = wl_shm_buffer_begin_access;

                extern fn wl_shm_buffer_end_access(buffer: *shm.Buffer) void;
                pub const endAccess = wl_shm_buffer_end_access;

                extern fn wl_shm_buffer_get_data(buffer: *shm.Buffer) ?*anyopaque;
                pub const getData = wl_shm_buffer_get_data;

                extern fn wl_shm_buffer_get_format(buffer: *shm.Buffer) u32;
                pub const getFormat = wl_shm_buffer_get_format;

                extern fn wl_shm_buffer_get_height(buffer: *shm.Buffer) i32;
                pub const getHeight = wl_shm_buffer_get_height;

                extern fn wl_shm_buffer_get_width(buffer: *shm.Buffer) i32;
                pub const getWidth = wl_shm_buffer_get_width;

                extern fn wl_shm_buffer_get_stride(buffer: *shm.Buffer) i32;
                pub const getStride = wl_shm_buffer_get_stride;

                extern fn wl_shm_buffer_ref_pool(buffer: *shm.Buffer) *Pool;
                pub const refPool = wl_shm_buffer_ref_pool;
            };

            pub const Pool = opaque {
                extern fn wl_shm_pool_unref(pool: *Pool) void;
                pub const unref = wl_shm_pool_unref;
            };
        };

        /// The core global object.  This is a special singleton object.  It
        /// is used for internal Wayland protocol features.
        pub const Display = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.display.interface;
            pub const Error = common.wl.display.Error;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Display {
                return @ptrCast(try server.wl.Resource.create(_client, Display, _version, _id));
            }
            pub fn destroy(_display: *Display) void {
                return @as(*server.wl.Resource, @ptrCast(_display)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Display {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_display: *Display) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_display)).getLink();
            }
            pub fn getClient(_display: *Display) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_display)).getClient();
            }
            pub fn getId(_display: *Display) u32 {
                return @as(*server.wl.Resource, @ptrCast(_display)).getId();
            }
            pub fn getVersion(_display: *Display) u32 {
                return @as(*server.wl.Resource, @ptrCast(_display)).getVersion();
            }
            pub fn postNoMemory(_display: *Display) void {
                return @as(*server.wl.Resource, @ptrCast(_display)).postNoMemory();
            }
            pub fn getUserData(_display: *Display) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_display)).getUserData();
            }
            pub fn postError(_display: *Display, _err: Error, _message: [*:0]const u8) void {
                return @as(*server.wl.Resource, @ptrCast(_display)).postError(@intCast(@intFromEnum(_err)), _message);
            }
            pub const Request = union(enum) {
                /// The sync request asks the server to emit the 'done' event
                /// on the returned wl_callback object.  Since requests are
                /// handled in-order and events are delivered in-order, this can
                /// be used as a barrier to ensure all previous requests and the
                /// resulting events have been handled.
                ///
                /// The object returned by this request will be destroyed by the
                /// compositor after the callback is fired and as such the client must not
                /// attempt to use it after that point.
                ///
                /// The callback_data passed in the callback is undefined and should be ignored.
                sync: struct {
                    callback: u32,
                },

                /// This request creates a registry object that allows the client
                /// to list and bind the global objects available from the
                /// compositor.
                ///
                /// It should be noted that the server side resources consumed in
                /// response to a get_registry request can only be released when the
                /// client disconnects, not when the client side proxy is destroyed.
                /// Therefore, clients should invoke get_registry as infrequently as
                /// possible to avoid wasting memory.
                get_registry: struct {
                    registry: u32,
                },
            };
            pub inline fn setHandler(
                _display: *Display,
                comptime T: type,
                handle_request: *const fn (_display: *Display, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_display: *Display, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_display);
                _resource.setDispatcher(
                    common.Dispatcher(Display, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Display, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// The error event is sent out when a fatal (non-recoverable)
            /// error has occurred.  The object_id argument is the object
            /// where the error occurred, most often in response to a request
            /// to that object.  The code identifies the error and is defined
            /// by the object interface.  As such, each interface defines its
            /// own set of error codes.  The message is a brief description
            /// of the error, for (debugging) convenience.
            pub fn sendError(_display: *Display, _object_id: *common.Object, _code: u32, _message: [*:0]const u8) void {
                const _resource: *server.wl.Resource = @ptrCast(_display);
                var _args = [_]common.Argument{
                    .{ .o = @ptrCast(_object_id) },
                    .{ .u = _code },
                    .{ .s = _message },
                };
                _resource.postEvent(0, &_args);
            }

            /// This event is used internally by the object ID management
            /// logic. When a client deletes an object that it had created,
            /// the server will send this event to acknowledge that it has
            /// seen the delete request. When the client receives this event,
            /// it will know that it can safely reuse the object ID.
            pub fn sendDeleteId(_display: *Display, _id: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_display);
                var _args = [_]common.Argument{
                    .{ .u = _id },
                };
                _resource.postEvent(1, &_args);
            }
        };

        /// The singleton global registry object.  The server has a number of
        /// global objects that are available to all clients.  These objects
        /// typically represent an actual object in the server (for example,
        /// an input device) or they are singleton objects that provide
        /// extension functionality.
        ///
        /// When a client creates a registry object, the registry object
        /// will emit a global event for each global currently in the
        /// registry.  Globals come and go as a result of device or
        /// monitor hotplugs, reconfiguration or other events, and the
        /// registry will send out global and global_remove events to
        /// keep the client up to date with the changes.  To mark the end
        /// of the initial burst of events, the client can use the
        /// wl_display.sync request immediately after calling
        /// wl_display.get_registry.
        ///
        /// A client can bind to a global object by using the bind
        /// request.  This creates a client-side handle that lets the object
        /// emit events to the client and lets the client invoke requests on
        /// the object.
        pub const Registry = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.registry.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Registry {
                return @ptrCast(try server.wl.Resource.create(_client, Registry, _version, _id));
            }
            pub fn destroy(_registry: *Registry) void {
                return @as(*server.wl.Resource, @ptrCast(_registry)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Registry {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_registry: *Registry) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_registry)).getLink();
            }
            pub fn getClient(_registry: *Registry) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_registry)).getClient();
            }
            pub fn getId(_registry: *Registry) u32 {
                return @as(*server.wl.Resource, @ptrCast(_registry)).getId();
            }
            pub fn getVersion(_registry: *Registry) u32 {
                return @as(*server.wl.Resource, @ptrCast(_registry)).getVersion();
            }
            pub fn postNoMemory(_registry: *Registry) void {
                return @as(*server.wl.Resource, @ptrCast(_registry)).postNoMemory();
            }
            pub fn getUserData(_registry: *Registry) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_registry)).getUserData();
            }
            pub const Request = union(enum) {
                /// Binds a new, client-created object to the server using the
                /// specified name as the identifier.
                bind: struct {
                    name: u32,
                    interface_name: [*:0]const u8,
                    version: u32,
                    id: u32,
                },
            };
            pub inline fn setHandler(
                _registry: *Registry,
                comptime T: type,
                handle_request: *const fn (_registry: *Registry, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_registry: *Registry, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_registry);
                _resource.setDispatcher(
                    common.Dispatcher(Registry, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Registry, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// Notify the client of global objects.
            ///
            /// The event notifies the client that a global object with
            /// the given name is now available, and it implements the
            /// given version of the given interface.
            pub fn sendGlobal(_registry: *Registry, _name: u32, _interface: [*:0]const u8, _version: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_registry);
                var _args = [_]common.Argument{
                    .{ .u = _name },
                    .{ .s = _interface },
                    .{ .u = _version },
                };
                _resource.postEvent(0, &_args);
            }

            /// Notify the client of removed global objects.
            ///
            /// This event notifies the client that the global identified
            /// by name is no longer available.  If the client bound to
            /// the global using the bind request, the client should now
            /// destroy that object.
            ///
            /// The object remains valid and requests to the object will be
            /// ignored until the client destroys it, to avoid races between
            /// the global going away and a client sending a request to it.
            pub fn sendGlobalRemove(_registry: *Registry, _name: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_registry);
                var _args = [_]common.Argument{
                    .{ .u = _name },
                };
                _resource.postEvent(1, &_args);
            }
        };

        /// Clients can handle the 'done' event to get notified when
        /// the related request is done.
        ///
        /// Note, because wl_callback objects are created from multiple independent
        /// factory interfaces, the wl_callback interface is frozen at version 1.
        pub const Callback = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.callback.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Callback {
                return @ptrCast(try server.wl.Resource.create(_client, Callback, _version, _id));
            }
            pub fn destroy(_callback: *Callback) void {
                return @as(*server.wl.Resource, @ptrCast(_callback)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Callback {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_callback: *Callback) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_callback)).getLink();
            }
            pub fn getClient(_callback: *Callback) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_callback)).getClient();
            }
            pub fn getId(_callback: *Callback) u32 {
                return @as(*server.wl.Resource, @ptrCast(_callback)).getId();
            }
            pub fn getVersion(_callback: *Callback) u32 {
                return @as(*server.wl.Resource, @ptrCast(_callback)).getVersion();
            }
            pub fn postNoMemory(_callback: *Callback) void {
                return @as(*server.wl.Resource, @ptrCast(_callback)).postNoMemory();
            }
            pub fn getUserData(_callback: *Callback) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_callback)).getUserData();
            }
            pub inline fn setHandler(
                _callback: *Callback,
                comptime T: type,
                comptime handle_destroy: ?fn (_callback: *Callback, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_callback);
                _resource.setDispatcher(
                    null,
                    null,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Callback, @ptrCast(__resource)),
                                @as(?*anyopaque, @ptrFromInt(@intFromPtr(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// Notify the client when the related request is done.
            pub fn destroySendDone(_callback: *Callback, _callback_data: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_callback);
                var _args = [_]common.Argument{
                    .{ .u = _callback_data },
                };
                _resource.postEvent(0, &_args);
                _resource.destroy();
            }
        };

        /// A buffer provides the content for a wl_surface. Buffers are
        /// created through factory interfaces such as wl_shm, wp_linux_buffer_params
        /// (from the linux-dmabuf protocol extension) or similar. It has a width and
        /// a height and can be attached to a wl_surface, but the mechanism by which a
        /// client provides and updates the contents is defined by the buffer factory
        /// interface.
        ///
        /// Color channels are assumed to be electrical rather than optical (in other
        /// words, encoded with a transfer function) unless otherwise specified. If
        /// the buffer uses a format that has an alpha channel, the alpha channel is
        /// assumed to be premultiplied into the electrical color channel values
        /// (after transfer function encoding) unless otherwise specified.
        ///
        /// Note, because wl_buffer objects are created from multiple independent
        /// factory interfaces, the wl_buffer interface is frozen at version 1.
        pub const Buffer = opaque {
            pub const generated_version = 1;
            pub const interface = &common.wl.buffer.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*Buffer {
                return @ptrCast(try server.wl.Resource.create(_client, Buffer, _version, _id));
            }
            pub fn destroy(_buffer: *Buffer) void {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *Buffer {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_buffer: *Buffer) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).getLink();
            }
            pub fn getClient(_buffer: *Buffer) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).getClient();
            }
            pub fn getId(_buffer: *Buffer) u32 {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).getId();
            }
            pub fn getVersion(_buffer: *Buffer) u32 {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).getVersion();
            }
            pub fn postNoMemory(_buffer: *Buffer) void {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).postNoMemory();
            }
            pub fn getUserData(_buffer: *Buffer) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_buffer)).getUserData();
            }
            pub const Request = union(enum) {
                /// Destroy a buffer. If and how you need to release the backing
                /// storage is defined by the buffer factory interface.
                ///
                /// For possible side-effects to a surface, see wl_surface.attach.
                destroy: void,
            };
            pub inline fn setHandler(
                _buffer: *Buffer,
                comptime T: type,
                handle_request: *const fn (_buffer: *Buffer, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_buffer: *Buffer, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_buffer);
                _resource.setDispatcher(
                    common.Dispatcher(Buffer, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*Buffer, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// Sent when this wl_buffer is no longer used by the compositor.
            ///
            /// For more information on when release events may or may not be sent,
            /// and what consequences it has, please see the description of
            /// wl_surface.attach.
            ///
            /// If a client receives a release event before the frame callback
            /// requested in the same wl_surface.commit that attaches this
            /// wl_buffer to a surface, then the client is immediately free to
            /// reuse the buffer and its backing storage, and does not need a
            /// second buffer for the next surface content update. Typically
            /// this is possible, when the compositor maintains a copy of the
            /// wl_surface contents, e.g. as a GL texture. This is an important
            /// optimization for GL(ES) compositors with wl_shm clients.
            pub fn sendRelease(_buffer: *Buffer) void {
                const _resource: *server.wl.Resource = @ptrCast(_buffer);
                _resource.postEvent(0, null);
            }
        };
    };
    pub const river = struct {
        /// A global factory for river_layout_v3 objects.
        pub const LayoutManagerV3 = opaque {
            pub const generated_version = 2;
            pub const interface = &common.river.layout_manager_v3.interface;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*LayoutManagerV3 {
                return @ptrCast(try server.wl.Resource.create(_client, LayoutManagerV3, _version, _id));
            }
            pub fn destroy(_layout_manager_v3: *LayoutManagerV3) void {
                return @as(*server.wl.Resource, @ptrCast(_layout_manager_v3)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *LayoutManagerV3 {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_layout_manager_v3: *LayoutManagerV3) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_layout_manager_v3)).getLink();
            }
            pub fn getClient(_layout_manager_v3: *LayoutManagerV3) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_layout_manager_v3)).getClient();
            }
            pub fn getId(_layout_manager_v3: *LayoutManagerV3) u32 {
                return @as(*server.wl.Resource, @ptrCast(_layout_manager_v3)).getId();
            }
            pub fn getVersion(_layout_manager_v3: *LayoutManagerV3) u32 {
                return @as(*server.wl.Resource, @ptrCast(_layout_manager_v3)).getVersion();
            }
            pub fn postNoMemory(_layout_manager_v3: *LayoutManagerV3) void {
                return @as(*server.wl.Resource, @ptrCast(_layout_manager_v3)).postNoMemory();
            }
            pub fn getUserData(_layout_manager_v3: *LayoutManagerV3) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_layout_manager_v3)).getUserData();
            }
            pub const Request = union(enum) {
                /// This request indicates that the client will not use the
                /// river_layout_manager object any more. Objects that have been created
                /// through this instance are not affected.
                destroy: void,
                /// This creates a new river_layout_v3 object for the given wl_output.
                ///
                /// All layout related communication is done through this interface.
                ///
                /// The namespace is used by the compositor to decide which river_layout_v3
                /// object will receive layout demands for the output.
                ///
                /// The namespace is required to be be unique per-output. Furthermore,
                /// two separate clients may not share a namespace on separate outputs. If
                /// these conditions are not upheld, the the namespace_in_use event will
                /// be sent directly after creation of the river_layout_v3 object.
                get_layout: struct {
                    id: u32,
                    output: *server.wl.Output,
                    namespace: [*:0]const u8,
                },
            };
            pub inline fn setHandler(
                _layout_manager_v3: *LayoutManagerV3,
                comptime T: type,
                handle_request: *const fn (_layout_manager_v3: *LayoutManagerV3, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_layout_manager_v3: *LayoutManagerV3, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_layout_manager_v3);
                _resource.setDispatcher(
                    common.Dispatcher(LayoutManagerV3, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*LayoutManagerV3, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
        };

        /// This interface allows clients to receive layout demands from the
        /// compositor for a specific output and subsequently propose positions and
        /// dimensions of individual views.
        pub const LayoutV3 = opaque {
            pub const generated_version = 2;
            pub const interface = &common.river.layout_v3.interface;
            pub const Error = common.river.layout_v3.Error;
            pub fn create(_client: *server.wl.Client, _version: u32, _id: u32) !*LayoutV3 {
                return @ptrCast(try server.wl.Resource.create(_client, LayoutV3, _version, _id));
            }
            pub fn destroy(_layout_v3: *LayoutV3) void {
                return @as(*server.wl.Resource, @ptrCast(_layout_v3)).destroy();
            }
            pub fn fromLink(_link: *server.wl.list.Link) *LayoutV3 {
                return @ptrCast(server.wl.Resource.fromLink(_link));
            }
            pub fn getLink(_layout_v3: *LayoutV3) *server.wl.list.Link {
                return @as(*server.wl.Resource, @ptrCast(_layout_v3)).getLink();
            }
            pub fn getClient(_layout_v3: *LayoutV3) *server.wl.Client {
                return @as(*server.wl.Resource, @ptrCast(_layout_v3)).getClient();
            }
            pub fn getId(_layout_v3: *LayoutV3) u32 {
                return @as(*server.wl.Resource, @ptrCast(_layout_v3)).getId();
            }
            pub fn getVersion(_layout_v3: *LayoutV3) u32 {
                return @as(*server.wl.Resource, @ptrCast(_layout_v3)).getVersion();
            }
            pub fn postNoMemory(_layout_v3: *LayoutV3) void {
                return @as(*server.wl.Resource, @ptrCast(_layout_v3)).postNoMemory();
            }
            pub fn getUserData(_layout_v3: *LayoutV3) ?*anyopaque {
                return @as(*server.wl.Resource, @ptrCast(_layout_v3)).getUserData();
            }
            pub fn postError(_layout_v3: *LayoutV3, _err: Error, _message: [*:0]const u8) void {
                return @as(*server.wl.Resource, @ptrCast(_layout_v3)).postError(@intCast(@intFromEnum(_err)), _message);
            }
            pub const Request = union(enum) {
                /// This request indicates that the client will not use the river_layout_v3
                /// object any more.
                destroy: void,
                /// This request proposes a size and position for a view in the layout demand
                /// with matching serial.
                ///
                /// A client must send this request for every view that is part of the
                /// layout demand. The number of views in the layout is given by the
                /// view_count argument of the layout_demand event. Pushing too many or
                /// too few view dimensions is a protocol error.
                ///
                /// The x and y coordinates are relative to the usable area of the output,
                /// with (0,0) as the top left corner.
                push_view_dimensions: struct {
                    x: i32,
                    y: i32,
                    width: u32,
                    height: u32,
                    serial: u32,
                },

                /// This request indicates that the client is done pushing dimensions
                /// and the compositor may apply the layout. This completes the layout
                /// demand with matching serial, any other requests sent with the serial
                /// are a protocol error.
                ///
                /// The layout_name argument is a user-facing name or short description
                /// of the layout that is being committed. The compositor may for example
                /// display this on a status bar, though what exactly is done with it is
                /// left to the compositor's discretion.
                ///
                /// The compositor is free to use this proposed layout however it chooses,
                /// including ignoring it.
                commit: struct {
                    layout_name: [*:0]const u8,
                    serial: u32,
                },
            };
            pub inline fn setHandler(
                _layout_v3: *LayoutV3,
                comptime T: type,
                handle_request: *const fn (_layout_v3: *LayoutV3, request: Request, data: T) void,
                comptime handle_destroy: ?fn (_layout_v3: *LayoutV3, data: T) void,
                _data: T,
            ) void {
                const _resource: *server.wl.Resource = @ptrCast(_layout_v3);
                _resource.setDispatcher(
                    common.Dispatcher(LayoutV3, T).dispatcher,
                    handle_request,
                    @ptrFromInt(@intFromPtr(_data)),
                    if (handle_destroy) |_handler| struct {
                        fn _wrapper(__resource: *server.wl.Resource) callconv(.c) void {
                            @call(.always_inline, _handler, .{
                                @as(*LayoutV3, @ptrCast(__resource)),
                                @as(T, @ptrCast(@alignCast(__resource.getUserData()))),
                            });
                        }
                    }._wrapper else null,
                );
            }
            /// After this event is sent, all requests aside from the destroy event
            /// will be ignored by the server. If the client wishes to try again with
            /// a different namespace they must create a new river_layout_v3 object.
            pub fn sendNamespaceInUse(_layout_v3: *LayoutV3) void {
                const _resource: *server.wl.Resource = @ptrCast(_layout_v3);
                _resource.postEvent(0, null);
            }

            /// The compositor sends this event to inform the client that it requires a
            /// layout for a set of views.
            ///
            /// The usable width and height indicate the space in which the client
            /// can safely position views without interfering with desktop widgets
            /// such as panels.
            ///
            /// The serial of this event is used to identify subsequent requests as
            /// belonging to this layout demand. Beware that the client might need
            /// to handle multiple layout demands at the same time.
            ///
            /// The server will ignore responses to all but the most recent layout
            /// demand. Thus, clients are only required to respond to the most recent
            /// layout_demand received. If a newer layout_demand is received before
            /// the client has finished responding to an old demand, the client should
            /// abort work on the old demand as any further work would be wasted.
            pub fn sendLayoutDemand(_layout_v3: *LayoutV3, _view_count: u32, _usable_width: u32, _usable_height: u32, _tags: u32, _serial: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_layout_v3);
                var _args = [_]common.Argument{
                    .{ .u = _view_count },
                    .{ .u = _usable_width },
                    .{ .u = _usable_height },
                    .{ .u = _tags },
                    .{ .u = _serial },
                };
                _resource.postEvent(1, &_args);
            }

            /// This event informs the client of a command sent to it by the user.
            ///
            /// The semantic meaning of the command is left for the client to
            /// decide. It is also free to ignore it entirely if it so chooses.
            ///
            /// A layout_demand will be sent after this event if the compositor is
            /// currently using this layout object to arrange the output.
            ///
            /// If version 2 or higher of the river_layout_v3 object is bound, the
            /// user_command_tags event is guaranteed to be sent directly before the
            /// user_command event.
            pub fn sendUserCommand(_layout_v3: *LayoutV3, _command: [*:0]const u8) void {
                const _resource: *server.wl.Resource = @ptrCast(_layout_v3);
                var _args = [_]common.Argument{
                    .{ .s = _command },
                };
                _resource.postEvent(2, &_args);
            }

            /// If version 2 or higher of the river_layout_v3 object is bound, this
            /// event will be sent directly before every user_command event. This allows
            /// layout generators to be aware of the active tags when a user command is
            /// sent. This is necessary for generators wanting to keep settings on a
            /// per-tag basis.
            pub fn sendUserCommandTags(_layout_v3: *LayoutV3, _tags: u32) void {
                const _resource: *server.wl.Resource = @ptrCast(_layout_v3);
                var _args = [_]common.Argument{
                    .{ .u = _tags },
                };
                _resource.postEvent(3, &_args);
            }
        };
    };
};

const common = struct {
    const Object = opaque {};

    const Message = extern struct {
        name: [*:0]const u8,
        signature: [*:0]const u8,
        types: ?[*]const ?*const Interface,
    };

    const Interface = extern struct {
        name: [*:0]const u8,
        version: c_int,
        method_count: c_int,
        methods: ?[*]const Message,
        event_count: c_int,
        events: ?[*]const Message,
    };

    const list = struct {
        pub const Link = extern struct {
            prev: ?*Link,
            next: ?*Link,

            pub fn init(link: *Link) void {
                link.* = .{ .prev = link, .next = link };
            }

            pub fn insert(link: *Link, other: *Link) void {
                other.prev = link;
                other.next = link.next;
                link.next = other;
                other.next.?.prev = other;
            }

            pub fn remove(link: *Link) void {
                link.prev.?.next = link.next;
                link.next.?.prev = link.prev;
                link.* = .{ .prev = null, .next = null };
            }

            pub fn replaceWith(link: *Link, other: *Link) void {
                other.next = link.next;
                other.next.?.prev = other;
                other.prev = link.prev;
                other.prev.?.next = other;

                link.* = .{ .prev = null, .next = null };
            }

            pub fn swapWith(link: *Link, other: *Link) void {
                const old_other_prev = other.prev.?;
                other.remove();

                link.replaceWith(other);

                if (old_other_prev == link) {
                    other.insert(link);
                } else {
                    old_other_prev.insert(link);
                }
            }

            /// private helper that doesn't handle empty lists and assumes that
            /// other is the link of a Head.
            fn insertList(link: *Link, other: *Link) void {
                other.next.?.prev = link;
                other.prev.?.next = link.next;
                link.next.?.prev = other.prev;
                link.next = other.next;

                other.init();
            }
        };

        pub const Direction = enum {
            forward,
            reverse,
        };

        /// This has the same ABI as wl.list.Link/wl_list. If link_field is null, then
        /// T.getLink()/T.fromLink() will be used. This allows for compatiability
        /// with wl.Client and wl.Resource
        pub fn Head(comptime T: type, comptime link_field: ?@Type(.enum_literal)) type {
            return extern struct {
                const Self = @This();

                link: Link,

                pub fn init(head: *Self) void {
                    head.link.init();
                }

                pub fn prepend(head: *Self, elem: *T) void {
                    head.link.insert(linkFromElem(elem));
                }

                pub fn append(head: *Self, elem: *T) void {
                    head.link.prev.?.insert(linkFromElem(elem));
                }

                pub fn prependList(head: *Self, other: *Self) void {
                    if (other.empty()) return;
                    head.link.insertList(&other.link);
                }

                pub fn appendList(head: *Self, other: *Self) void {
                    if (other.empty()) return;
                    head.link.prev.?.insertList(&other.link);
                }

                pub fn first(head: *Self) ?*T {
                    if (head.empty()) {
                        return null;
                    } else {
                        return elemFromLink(head.link.next.?);
                    }
                }

                pub fn last(head: *Self) ?*T {
                    if (head.empty()) {
                        return null;
                    } else {
                        return elemFromLink(head.link.prev.?);
                    }
                }

                pub fn length(head: *const Self) usize {
                    var count: usize = 0;
                    var current = head.link.next.?;
                    while (current != &head.link) : (current = current.next.?) {
                        count += 1;
                    }
                    return count;
                }

                pub fn empty(head: *const Self) bool {
                    return head.link.next == &head.link;
                }

                /// Removal of elements during iteration is illegal
                pub fn Iterator(comptime direction: Direction) type {
                    return struct {
                        head: *Link,
                        current: *Link,

                        pub fn next(it: *@This()) ?*T {
                            it.current = switch (direction) {
                                .forward => it.current.next.?,
                                .reverse => it.current.prev.?,
                            };
                            if (it.current == it.head) return null;
                            return elemFromLink(it.current);
                        }
                    };
                }

                /// Removal of elements during iteration is illegal
                pub fn iterator(head: *Self, comptime direction: Direction) Iterator(direction) {
                    return .{ .head = &head.link, .current = &head.link };
                }

                /// Removal of the current element during iteration is permitted.
                /// Removal of other elements is illegal.
                pub fn SafeIterator(comptime direction: Direction) type {
                    return struct {
                        head: *Link,
                        current: *Link,
                        future: *Link,

                        pub fn next(it: *@This()) ?*T {
                            it.current = it.future;
                            it.future = switch (direction) {
                                .forward => it.future.next.?,
                                .reverse => it.future.prev.?,
                            };
                            if (it.current == it.head) return null;
                            return elemFromLink(it.current);
                        }
                    };
                }

                /// Removal of the current element during iteration is permitted.
                /// Removal of other elements is illegal.
                pub fn safeIterator(head: *Self, comptime direction: Direction) SafeIterator(direction) {
                    return .{
                        .head = &head.link,
                        .current = &head.link,
                        .future = switch (direction) {
                            .forward => head.link.next.?,
                            .reverse => head.link.prev.?,
                        },
                    };
                }

                fn linkFromElem(elem: *T) *Link {
                    if (link_field) |f| {
                        return &@field(elem, @tagName(f));
                    } else {
                        return elem.getLink();
                    }
                }

                fn elemFromLink(link: *Link) *T {
                    if (link_field) |f| {
                        return @fieldParentPtr(@tagName(f), link);
                    } else {
                        return T.fromLink(link);
                    }
                }
            };
        }
    };

    const Array = extern struct {
        size: usize,
        alloc: usize,
        data: ?*anyopaque,

        /// Does not clone memory
        pub fn fromArrayList(comptime T: type, array_list: std.ArrayList(T)) Array {
            return Array{
                .size = array_list.items.len * @sizeOf(T),
                .alloc = array_list.capacity * @sizeOf(T),
                .data = array_list.items.ptr,
            };
        }

        pub fn slice(array: Array, comptime T: type) []align(4) T {
            const data = array.data orelse return &[0]T{};
            // The wire protocol/libwayland only guarantee 32-bit word alignment.
            const ptr: [*]align(4) T = @ptrCast(@alignCast(data));
            return ptr[0..@divExact(array.size, @sizeOf(T))];
        }
    };

    /// A 24.8 signed fixed-point number.
    const Fixed = enum(i32) {
        _,

        pub fn toInt(f: Fixed) i24 {
            return @truncate(@intFromEnum(f) >> 8);
        }

        pub fn fromInt(i: i24) Fixed {
            return @enumFromInt(@as(i32, i) << 8);
        }

        pub fn toDouble(f: Fixed) f64 {
            return @as(f64, @floatFromInt(@intFromEnum(f))) / 256;
        }

        pub fn fromDouble(d: f64) Fixed {
            return @enumFromInt(@as(i32, @intFromFloat(d * 256)));
        }
    };

    const Argument = extern union {
        i: i32,
        u: u32,
        f: Fixed,
        s: ?[*:0]const u8,
        o: ?*Object,
        n: u32,
        a: ?*Array,
        h: i32,
    };

    fn Dispatcher(comptime Obj: type, comptime Data: type) type {
        const client_side = @hasDecl(Obj, "Event");
        const Payload = if (client_side) Obj.Event else Obj.Request;
        return struct {
            fn dispatcher(
                implementation: ?*const anyopaque,
                object: if (client_side) *client.wl.Proxy else *server.wl.Resource,
                opcode: u32,
                _: *const Message,
                args: [*]Argument,
            ) callconv(.c) c_int {
                inline for (@typeInfo(Payload).@"union".fields, 0..) |payload_field, payload_num| {
                    if (payload_num == opcode) {
                        var payload_data: payload_field.type = undefined;
                        if (payload_field.type != void) {
                            inline for (@typeInfo(payload_field.type).@"struct".fields, 0..) |f, i| {
                                switch (@typeInfo(f.type)) {
                                    // signed/unsigned ints, fds, new_ids, bitfield enums
                                    .int, .@"struct" => @field(payload_data, f.name) = @as(f.type, @bitCast(args[i].u)),
                                    // objects, strings, arrays
                                    .pointer, .optional => @field(payload_data, f.name) = @as(f.type, @ptrFromInt(@intFromPtr(args[i].o))),
                                    // non-bitfield enums
                                    .@"enum" => @field(payload_data, f.name) = @as(f.type, @enumFromInt(args[i].i)),
                                    else => unreachable,
                                }
                            }
                        }

                        const HandlerFn = fn (*Obj, Payload, Data) void;
                        @as(*const HandlerFn, @ptrCast(@alignCast(implementation)))(
                            @as(*Obj, @ptrCast(object)),
                            @unionInit(Payload, payload_field.name, payload_data),
                            @as(Data, @ptrFromInt(@intFromPtr(object.getUserData()))),
                        );

                        return 0;
                    }
                }
                unreachable;
            }
        };
    }
    const wl = struct {
        const display = struct {
            const interface: common.Interface = .{
                .name = "wl_display",
                .version = 1,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "sync",
                        .signature = "n",
                        .types = &.{
                            &common.wl.callback.interface,
                        },
                    },
                    .{
                        .name = "get_registry",
                        .signature = "n",
                        .types = &.{
                            &common.wl.registry.interface,
                        },
                    },
                },
                .event_count = 2,
                .events = &.{
                    .{
                        .name = "error",
                        .signature = "ous",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "delete_id",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
            /// These errors are global and can be emitted in response to any
            /// server request.
            const Error = enum(c_int) {
                invalid_object = 0,
                invalid_method = 1,
                no_memory = 2,
                implementation = 3,
                _,
            };
        };
        const registry = struct {
            const interface: common.Interface = .{
                .name = "wl_registry",
                .version = 1,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "bind",
                        .signature = "usun",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                },
                .event_count = 2,
                .events = &.{
                    .{
                        .name = "global",
                        .signature = "usu",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "global_remove",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const callback = struct {
            const interface: common.Interface = .{
                .name = "wl_callback",
                .version = 1,
                .method_count = 0,
                .methods = null,
                .event_count = 1,
                .events = &.{
                    .{
                        .name = "done",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const buffer = struct {
            const interface: common.Interface = .{
                .name = "wl_buffer",
                .version = 1,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                },
                .event_count = 1,
                .events = &.{
                    .{
                        .name = "release",
                        .signature = "",
                        .types = null,
                    },
                },
            };
        };
        const compositor = struct {
            const interface: common.Interface = .{
                .name = "wl_compositor",
                .version = 6,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "create_surface",
                        .signature = "n",
                        .types = &.{
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "create_region",
                        .signature = "n",
                        .types = &.{
                            &common.wl.region.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const surface = struct {
            const interface: common.Interface = .{
                .name = "wl_surface",
                .version = 6,
                .method_count = 11,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "attach",
                        .signature = "?oii",
                        .types = &.{
                            &common.wl.buffer.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "damage",
                        .signature = "iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "frame",
                        .signature = "n",
                        .types = &.{
                            &common.wl.callback.interface,
                        },
                    },
                    .{
                        .name = "set_opaque_region",
                        .signature = "?o",
                        .types = &.{
                            &common.wl.region.interface,
                        },
                    },
                    .{
                        .name = "set_input_region",
                        .signature = "?o",
                        .types = &.{
                            &common.wl.region.interface,
                        },
                    },
                    .{
                        .name = "commit",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_buffer_transform",
                        .signature = "2i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "set_buffer_scale",
                        .signature = "3i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "damage_buffer",
                        .signature = "4iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "offset",
                        .signature = "5ii",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
                .event_count = 4,
                .events = &.{
                    .{
                        .name = "enter",
                        .signature = "o",
                        .types = &.{
                            &common.wl.output.interface,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "o",
                        .types = &.{
                            &common.wl.output.interface,
                        },
                    },
                    .{
                        .name = "preferred_buffer_scale",
                        .signature = "6i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "preferred_buffer_transform",
                        .signature = "6u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const region = struct {
            const interface: common.Interface = .{
                .name = "wl_region",
                .version = 1,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "add",
                        .signature = "iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "subtract",
                        .signature = "iiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const shm = struct {
            const interface: common.Interface = .{
                .name = "wl_shm",
                .version = 2,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "create_pool",
                        .signature = "nhi",
                        .types = &.{
                            &common.wl.shm_pool.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "release",
                        .signature = "2",
                        .types = null,
                    },
                },
                .event_count = 1,
                .events = &.{
                    .{
                        .name = "format",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const shm_pool = struct {
            const interface: common.Interface = .{
                .name = "wl_shm_pool",
                .version = 2,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "create_buffer",
                        .signature = "niiiiu",
                        .types = &.{
                            &common.wl.buffer.interface,
                            null,
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "resize",
                        .signature = "i",
                        .types = &.{
                            null,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const data_device_manager = struct {
            const interface: common.Interface = .{
                .name = "wl_data_device_manager",
                .version = 3,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "create_data_source",
                        .signature = "n",
                        .types = &.{
                            &common.wl.data_source.interface,
                        },
                    },
                    .{
                        .name = "get_data_device",
                        .signature = "no",
                        .types = &.{
                            &common.wl.data_device.interface,
                            &common.wl.seat.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const data_source = struct {
            const interface: common.Interface = .{
                .name = "wl_data_source",
                .version = 3,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "offer",
                        .signature = "s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_actions",
                        .signature = "3u",
                        .types = &.{
                            null,
                        },
                    },
                },
                .event_count = 6,
                .events = &.{
                    .{
                        .name = "target",
                        .signature = "?s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "send",
                        .signature = "sh",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "cancelled",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "dnd_drop_performed",
                        .signature = "3",
                        .types = null,
                    },
                    .{
                        .name = "dnd_finished",
                        .signature = "3",
                        .types = null,
                    },
                    .{
                        .name = "action",
                        .signature = "3u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const data_device = struct {
            const interface: common.Interface = .{
                .name = "wl_data_device",
                .version = 3,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "start_drag",
                        .signature = "?oo?ou",
                        .types = &.{
                            &common.wl.data_source.interface,
                            &common.wl.surface.interface,
                            &common.wl.surface.interface,
                            null,
                        },
                    },
                    .{
                        .name = "set_selection",
                        .signature = "?ou",
                        .types = &.{
                            &common.wl.data_source.interface,
                            null,
                        },
                    },
                    .{
                        .name = "release",
                        .signature = "2",
                        .types = null,
                    },
                },
                .event_count = 6,
                .events = &.{
                    .{
                        .name = "data_offer",
                        .signature = "n",
                        .types = &.{
                            &common.wl.data_offer.interface,
                        },
                    },
                    .{
                        .name = "enter",
                        .signature = "uoff?o",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                            &common.wl.data_offer.interface,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "motion",
                        .signature = "uff",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "drop",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "selection",
                        .signature = "?o",
                        .types = &.{
                            &common.wl.data_offer.interface,
                        },
                    },
                },
            };
        };
        const data_offer = struct {
            const interface: common.Interface = .{
                .name = "wl_data_offer",
                .version = 3,
                .method_count = 5,
                .methods = &.{
                    .{
                        .name = "accept",
                        .signature = "u?s",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "receive",
                        .signature = "sh",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "finish",
                        .signature = "3",
                        .types = null,
                    },
                    .{
                        .name = "set_actions",
                        .signature = "3uu",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
                .event_count = 3,
                .events = &.{
                    .{
                        .name = "offer",
                        .signature = "s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "source_actions",
                        .signature = "3u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "action",
                        .signature = "3u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const shell = struct {
            const interface: common.Interface = .{
                .name = "wl_shell",
                .version = 1,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "get_shell_surface",
                        .signature = "no",
                        .types = &.{
                            &common.wl.shell_surface.interface,
                            &common.wl.surface.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const shell_surface = struct {
            const interface: common.Interface = .{
                .name = "wl_shell_surface",
                .version = 1,
                .method_count = 10,
                .methods = &.{
                    .{
                        .name = "pong",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "move",
                        .signature = "ou",
                        .types = &.{
                            &common.wl.seat.interface,
                            null,
                        },
                    },
                    .{
                        .name = "resize",
                        .signature = "ouu",
                        .types = &.{
                            &common.wl.seat.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "set_toplevel",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_transient",
                        .signature = "oiiu",
                        .types = &.{
                            &common.wl.surface.interface,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "set_fullscreen",
                        .signature = "uu?o",
                        .types = &.{
                            null,
                            null,
                            &common.wl.output.interface,
                        },
                    },
                    .{
                        .name = "set_popup",
                        .signature = "ouoiiu",
                        .types = &.{
                            &common.wl.seat.interface,
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "set_maximized",
                        .signature = "?o",
                        .types = &.{
                            &common.wl.output.interface,
                        },
                    },
                    .{
                        .name = "set_title",
                        .signature = "s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "set_class",
                        .signature = "s",
                        .types = &.{
                            null,
                        },
                    },
                },
                .event_count = 3,
                .events = &.{
                    .{
                        .name = "ping",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "configure",
                        .signature = "uii",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "popup_done",
                        .signature = "",
                        .types = null,
                    },
                },
            };
        };
        const seat = struct {
            const interface: common.Interface = .{
                .name = "wl_seat",
                .version = 10,
                .method_count = 4,
                .methods = &.{
                    .{
                        .name = "get_pointer",
                        .signature = "n",
                        .types = &.{
                            &common.wl.pointer.interface,
                        },
                    },
                    .{
                        .name = "get_keyboard",
                        .signature = "n",
                        .types = &.{
                            &common.wl.keyboard.interface,
                        },
                    },
                    .{
                        .name = "get_touch",
                        .signature = "n",
                        .types = &.{
                            &common.wl.touch.interface,
                        },
                    },
                    .{
                        .name = "release",
                        .signature = "5",
                        .types = null,
                    },
                },
                .event_count = 2,
                .events = &.{
                    .{
                        .name = "capabilities",
                        .signature = "u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "name",
                        .signature = "2s",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const pointer = struct {
            const interface: common.Interface = .{
                .name = "wl_pointer",
                .version = 10,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "set_cursor",
                        .signature = "u?oii",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 11,
                .events = &.{
                    .{
                        .name = "enter",
                        .signature = "uoff",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "uo",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "motion",
                        .signature = "uff",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "button",
                        .signature = "uuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis",
                        .signature = "uuf",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "frame",
                        .signature = "5",
                        .types = null,
                    },
                    .{
                        .name = "axis_source",
                        .signature = "5u",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "axis_stop",
                        .signature = "5uu",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis_discrete",
                        .signature = "5ui",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis_value120",
                        .signature = "8ui",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "axis_relative_direction",
                        .signature = "9uu",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
            };
        };
        const keyboard = struct {
            const interface: common.Interface = .{
                .name = "wl_keyboard",
                .version = 10,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 6,
                .events = &.{
                    .{
                        .name = "keymap",
                        .signature = "uhu",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "enter",
                        .signature = "uoa",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                            null,
                        },
                    },
                    .{
                        .name = "leave",
                        .signature = "uo",
                        .types = &.{
                            null,
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "key",
                        .signature = "uuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "modifiers",
                        .signature = "uuuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "repeat_info",
                        .signature = "4ii",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
            };
        };
        const touch = struct {
            const interface: common.Interface = .{
                .name = "wl_touch",
                .version = 10,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 7,
                .events = &.{
                    .{
                        .name = "down",
                        .signature = "uuoiff",
                        .types = &.{
                            null,
                            null,
                            &common.wl.surface.interface,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "up",
                        .signature = "uui",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "motion",
                        .signature = "uiff",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "frame",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "cancel",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "shape",
                        .signature = "6iff",
                        .types = &.{
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "orientation",
                        .signature = "6if",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
            };
        };
        const output = struct {
            const interface: common.Interface = .{
                .name = "wl_output",
                .version = 4,
                .method_count = 1,
                .methods = &.{
                    .{
                        .name = "release",
                        .signature = "3",
                        .types = null,
                    },
                },
                .event_count = 6,
                .events = &.{
                    .{
                        .name = "geometry",
                        .signature = "iiiiissi",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "mode",
                        .signature = "uiii",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "done",
                        .signature = "2",
                        .types = null,
                    },
                    .{
                        .name = "scale",
                        .signature = "2i",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "name",
                        .signature = "4s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "description",
                        .signature = "4s",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
        };
        const subcompositor = struct {
            const interface: common.Interface = .{
                .name = "wl_subcompositor",
                .version = 1,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "get_subsurface",
                        .signature = "noo",
                        .types = &.{
                            &common.wl.subsurface.interface,
                            &common.wl.surface.interface,
                            &common.wl.surface.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const subsurface = struct {
            const interface: common.Interface = .{
                .name = "wl_subsurface",
                .version = 1,
                .method_count = 6,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_position",
                        .signature = "ii",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "place_above",
                        .signature = "o",
                        .types = &.{
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "place_below",
                        .signature = "o",
                        .types = &.{
                            &common.wl.surface.interface,
                        },
                    },
                    .{
                        .name = "set_sync",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "set_desync",
                        .signature = "",
                        .types = null,
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const fixes = struct {
            const interface: common.Interface = .{
                .name = "wl_fixes",
                .version = 1,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "destroy_registry",
                        .signature = "o",
                        .types = &.{
                            &common.wl.registry.interface,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
    };
    const river = struct {
        const layout_manager_v3 = struct {
            const interface: common.Interface = .{
                .name = "river_layout_manager_v3",
                .version = 2,
                .method_count = 2,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "get_layout",
                        .signature = "nos",
                        .types = &.{
                            &common.river.layout_v3.interface,
                            &common.wl.output.interface,
                            null,
                        },
                    },
                },
                .event_count = 0,
                .events = null,
            };
        };
        const layout_v3 = struct {
            const interface: common.Interface = .{
                .name = "river_layout_v3",
                .version = 2,
                .method_count = 3,
                .methods = &.{
                    .{
                        .name = "destroy",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "push_view_dimensions",
                        .signature = "iiuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "commit",
                        .signature = "su",
                        .types = &.{
                            null,
                            null,
                        },
                    },
                },
                .event_count = 4,
                .events = &.{
                    .{
                        .name = "namespace_in_use",
                        .signature = "",
                        .types = null,
                    },
                    .{
                        .name = "layout_demand",
                        .signature = "uuuuu",
                        .types = &.{
                            null,
                            null,
                            null,
                            null,
                            null,
                        },
                    },
                    .{
                        .name = "user_command",
                        .signature = "s",
                        .types = &.{
                            null,
                        },
                    },
                    .{
                        .name = "user_command_tags",
                        .signature = "2u",
                        .types = &.{
                            null,
                        },
                    },
                },
            };
            const Error = enum(c_int) {
                count_mismatch = 0,
                already_committed = 1,
                _,
            };
        };
    };
};
